---

id: apis

title: APIs

---
The basics of GraphQL is given in Prerequisites section. Here we will discuss how we have used GraphQL and different other APIs in our implementation.

## Queries
In short, query is a API exposed by Apollo Graph Query Language to fetch required object from the database. Queries are very useful as this prevents from overfetching and underfetching of data. We have used a lot of different queries based on different requirement. A brief detail is as follows:

Basic code for Executing any query is :
```bash
/** Responsible for executing Apollo Queries
 * @param {ApolloClient} apolloClient - Initialized Apollo Client
 * @param {gql} query - Query consisting of what we wanna fetch from DB
 * @param {payload} variables - Filter/conditions we wanna apply
 * @returns {[ResultSet]} array of result set
 */
const ExecuteQuery = async (apolloClient, query, variables) => {
  try {
    return apolloClient
      .query({
        query,
        variables
      });
  } catch (error) {
    throw error;
  }
}
```

An implementation code where this ExecuteQuery function is used is:
```bash
/**Method to pull master data based on tablename, clientname & rolename
 * @param {string} tableName - table name from which we want to pull master data
 * @param {string} clientName - client name for which we want to pull master data
 * @param {string} roleName - role for which we want to pul the master data
 * @returns {[masterdata]} - returns list of master data records
 */
const FetchMasterData = async (tableName, clientName, roleName) => {
  try {
    let input = {
      "input": {
        "Table": tableName,
        "Client": clientName,
        "Role": roleName
      }
    };
    const resp = await ExecuteQuery(GetApolloClient(gqlEndPoint), GETMASTERSDATA, input);
    return resp.data[apolloKeys.LoadMasters];
  } catch (error) {
    console.log(error);
    logAPIErrorData(error, { tableName, clientName, roleName }, consoleLogs.Utilities.Apollo.Operations.FetchMasterData)
  }
}
```

Similar to these we have different queries for quering Agents and Underwriter container to fetch agent and underwriter, Templates container to fetch coverage templates, Policy container for fetching policy object etc.

### Query Parameters

1. **Apollo Client Instance**:- GetApolloClient is function in which ApolloClient constuctor is called to initialize an instance of Apollo Client.
2. **Custom User Defined Query**:- Like GET_POLICY in above example. This is a specific query created in typedefinition of GraphQL used for fetching only the specified Nodes of the whole Policy object or any specific document stored in DB.

**Sample Query**
```bash
const GETMASTERSDATA = gql`
query LoadMasters($input: inpLoadMasters) {
  loadMasters(input: $input) {
    Code
    Role
    Description
    Status
    BillingType
		Company
		State
		PolicyType
		PayPlanDesc
		DownPaymentPct
		InstallmentCount
		Term
		InstallmentFee
		InstallmentPct
		DownDays
		PayPlanCode
		InstallmentDays
    City
    Zip
    County
  }
}
`;
```
- **query**:- Query here is equivalent to function word, but is used by Apollo to distinguish its nature.
- **LoadMasters**:- This is a custom name provided by developer for calling it.
- **inpLoadMasters**:- This the input object of type LoadMasters. More about this is covered in Apollo Prerequisites section.
- **Result Object**:- All the nodes we want in our output when reading a master object are specified here. **We cannot ask for anything which is not present in the type LoadMaster.**

3. **Variables**:- This is a variable input which is used to provide custom conditions for fetching the Objects as per given Query which statify this condition. All these conditions specified in input object are placed in **WHERE** clause in loadMasters query when quering the cosmos database.

## Fragments
A GraphQL fragment is a piece of logic that can be shared between multiple queries and mutations. Fragments let you construct sets of fields, and then include them in queries where you need to.

#### Example
```bash
const FORMS_FIELDS = gql`
fragment FormsFields on AutogeneratedMainType {
  Status
  FormName
  FormDesc
  Sequence
  FormType
  Template
  IsMandatory
  IsChecked
  AcordCode
  File
  Dmspath
}
`;
```
Every fragment includes a subset of the fields that belong to its associated type. In the above example, **the AutogeneratedMainType type must declare all fields mentioned for the FormsFields fragment to be valid.**

We can now include the FormsFields fragment in any number of queries and mutations that refer to AutogeneratedMainType objects, like so:
```bash
const GET_PRODUCT_FORMS = gql`
query GetForms($userName: String, $password: String, $grantType: String, $tokenUrl: String, $productCode: String, $transactionType: String, $formFactoryApiUrl: String, $policyNumber: String) {
getForms(userName: $userName, password: $password, grantType: $grantType, tokenURL: $tokenUrl, productCode: $productCode, transactionType: $transactionType, formFactoryAPIUrl: $formFactoryApiUrl, policyNumber: $policyNumber) {
    ...FormsFields
  }
}
`;
```
If we later change which fields are included in the FormsFields fragment, we automatically change which fields are included in operations that use the fragment. **This reduces the effort required to keep fields consistent across a set of operations.**


## Apollo Azure Functions

## Configuration in Blob
There are different configurations related to application, which are kept in blob storage. In this section we'll look into those configurations. Below image shows different category of configurations kept in blob storage.
>![Configuration_Folders](../../static/img/docs/apis/configurations.png)
>[Configuration in Blob](../../static/img/docs/apis/configurations.png)

**Note**:- For all the configuration we have followed a folder directory structure which is :- Client > LINES > LOB > then individual configuration files.

### 1. Assests Folder
All the static assests file logos, images and files related to any application is kept in this folder.

### 2. Config Folder
Inside the config folder all the major configuration required for a client implementation is kept. Some prime one's are:-
- **td.graphql** - This is the most important file which basically holds the different types of object permitted in the data model. Two component of this files are Input component which defines the input which is passed to the GQL function and type object defining the contituents of the object. Basically this is used by GQL function to validate your incoming request and save the valid data model in the database.

- **hookSchema.json** - This json files holds the configuration for all the custom hooks used by the project throughout the application flow. More about hooks is covered in hooks section.

- **raterconfig.json** - This file is used to transform our policy model into rater request format. The different rater needed parameter and there path in json format is kept here, which is used before calling rater by transformRaterRequets function.

- **uwRules.json** - This files holds different Underwriter rules which are specified by the client. The same file can be used to defining formFactory forms based on matching parameter in policy model. Also, payplan configuration can also be defined in this file. Different categories are separated using **type** parameter inside json object.

### 3. Model Folder
A data model can remain mostly consistent for same LOB and different states, but it can vary for different LOB's of the client. So the same data model is not preferred in this case. So this folder will keep the different data model for a specific client separated by there LOBs.

### 4. Schema Folder
This folder keeps the json format UI schema for different UI pages for each client. These schema are kept segregated by keeping them in folder structure mentioned above in notes. The schema path info is maintained in a json file named **UISchemaList** which is read by **UISCHEMAFETCHER** function and pull the schema flow wise (Quote, Application etc.)

### 5. Templates Folder
All the Email templates provided by client which are to be sent to insured, agent or underwriter under specified circumstances are kept here. These templates are handlerbar made templates which picks values dynamically from the policy model and sent a prepared email to the user.

## Apollo Server
Apollo server is a middle layer between Database and Application. All the requests send by application reaches this server and this server has different functions created to interact and update data in Cosmos Database.
The server instance basically takes 3 parameters:-

```bash
  //Initializing Apollo Server\'s Instance
  const server = new ApolloServer({
    typeDefs,
    resolvers,
    plugins: [GraphQlPlugin] //Passing custom plugin to execute extra functionalities & validations
  });
```
1. Typedefs - These is graphql object holding the detailed design of all the constituents of a data model. This is kept as separate object for every client, lob, state etc. in a blob storage.
2. Resolvers - These are basically the function used to query or update the data object in DB. These are basically our different queries and mutations. These are basically maintained in DIEP-SERVICE repository.
3. Plugins - Plugins is a custom functionality given by Graph QL which enables us to perform certain operation on data coming in request before (Pre) running any Query/Mutuation or after (Post) running and Query/Mutuation. These are maintained in DIEP-POS-COMPONENTS repository.